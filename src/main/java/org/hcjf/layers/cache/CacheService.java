package org.hcjf.layers.cache;

import org.hcjf.layers.Layers;
import org.hcjf.properties.LayerSystemProperties;
import org.hcjf.properties.SystemProperties;
import org.hcjf.service.Service;

import java.util.*;

/**
 * This service maintains cache instances schedule in order to invalidate cache periodically.
 */
public class CacheService extends Service<CacheServiceConsumer> {

    private static final Integer TIME_WINDOWS_SIZE = 1000;
    private static CacheService instance;

    private Map<Long, List<CacheLayerInterface<?>>> cacheLayers;

    private CacheService() {
        super(SystemProperties.get(LayerSystemProperties.Cache.SERVICE_NAME),
                SystemProperties.getInteger(LayerSystemProperties.Cache.SERVICE_PRIORITY));
    }

    @Override
    protected void init() {
        super.init();
        cacheLayers = new HashMap<>();
        fork(() -> {
            while(!Thread.currentThread().isInterrupted()) {
                try {
                    Long timeWindows = System.currentTimeMillis() / TIME_WINDOWS_SIZE * TIME_WINDOWS_SIZE;
                    Set<Long> tws = new TreeSet<>();
                    tws.addAll(cacheLayers.keySet());
                    for (Long tw : tws) {
                        if (timeWindows >= tw) {
                            List<CacheLayerInterface<?>> list = cacheLayers.remove(tw);
                            for (CacheLayerInterface<?> layer : list) {
                                invalidate(layer);
                            }
                        }
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    /**
     * Returns the singleton instance.
     * @return Singleton instance.
     */
    public static synchronized CacheService getInstance() {
        if(instance == null) {
            instance = new CacheService();
        }
        return instance;
    }

    /**
     * Calculates the time windows from specific timestamp.
     * @param timestamp Timestamp value.
     * @return Time windows id.
     */
    private Long calculateTimeWindows(Long timestamp) {
        return timestamp / TIME_WINDOWS_SIZE * TIME_WINDOWS_SIZE;
    }

    /**
     * Schedule cache instance in order to invalidate it periodically
     * @param cacheLayerInterface Cache instance.
     */
    private synchronized void scheduleCache(CacheLayerInterface<?> cacheLayerInterface) {
        Long timeWindows = calculateTimeWindows(System.currentTimeMillis() + cacheLayerInterface.timout());
        List<CacheLayerInterface<?>> list = cacheLayers.get(timeWindows);
        if(list == null) {
            list = new ArrayList<>();
            cacheLayers.put(timeWindows, list);
        }
        list.add(cacheLayerInterface);
    }

    /**
     * This method call to specific invalidate method of cache implementation and schedule cache instance.
     * @param cacheLayerInterface Cache instance.
     */
    private void invalidate(CacheLayerInterface<?> cacheLayerInterface) {
        cacheLayerInterface.invalidate();
        scheduleCache(cacheLayerInterface);
    }

    /**
     * This method register the consumer in the service.
     * @param consumer Object with the logic to consume the service.
     * @throws RuntimeException It contains exceptions generated by
     *                          the particular logic of each implementation.
     */
    @Override
    public void registerConsumer(CacheServiceConsumer consumer) {
        CacheLayerInterface cacheLayer = Layers.get(CacheLayerInterface.class, consumer.getCacheImpl());
        invalidate(cacheLayer);
    }

    /**
     * Unregister a specific consumer.
     * @param consumer Consumer to unregister.
     */
    @Override
    public void unregisterConsumer(CacheServiceConsumer consumer) {
    }
}
